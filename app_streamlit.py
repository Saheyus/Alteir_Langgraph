#!/usr/bin/env python3
"""
Interface Streamlit pour le syst√®me multi-agents GDD Alteir
"""
import streamlit as st
import sys
from pathlib import Path
import json
from datetime import datetime

sys.path.append(str(Path(__file__).parent))

# Configuration de la page
st.set_page_config(
    page_title="GDD Alteir - Multi-Agents",
    page_icon="ü§ñ",
    layout="wide"
)

# === OPTIMISATIONS: Lazy Loading avec Cache ===

@st.cache_resource(show_spinner="Chargement des d√©pendances...")
def load_workflow_dependencies(domain="personnages"):
    """Charge les d√©pendances lourdes une seule fois"""
    from workflows.content_workflow import ContentWorkflow
    from agents.writer_agent import WriterConfig
    
    if domain == "lieux":
        from config.domain_configs.lieux_config import LIEUX_CONFIG
        return ContentWorkflow, WriterConfig, LIEUX_CONFIG
    else:
        from config.domain_configs.personnages_config import PERSONNAGES_CONFIG
        return ContentWorkflow, WriterConfig, PERSONNAGES_CONFIG

@st.cache_data(ttl=60)
def get_outputs_count():
    """Cache le comptage des fichiers pour 60 secondes"""
    outputs_dir = Path("outputs")
    if outputs_dir.exists():
        return len(list(outputs_dir.glob("*.json")))
    return 0

@st.cache_data(ttl=30)
def list_output_files():
    """Cache la liste des fichiers pour 30 secondes"""
    outputs_dir = Path("outputs")
    if not outputs_dir.exists():
        return []
    
    json_files = sorted(
        outputs_dir.glob("*.json"),
        key=lambda p: p.stat().st_mtime,
        reverse=True
    )
    return [f.stem for f in json_files]

@st.cache_data
def load_result_file(file_stem: str):
    """Cache le chargement d'un fichier r√©sultat"""
    outputs_dir = Path("outputs")
    json_path = outputs_dir / f"{file_stem}.json"
    
    if not json_path.exists():
        return None
    
    with open(json_path, 'r', encoding='utf-8') as f:
        return json.load(f)

# Style CSS
st.markdown("""
<style>
/* R√©duire l'espace en haut */
.block-container {
    padding-top: 1rem !important;
    padding-bottom: 0rem;
}

/* En-t√™te principal avec gradient et design moderne */
.main-header {
    font-size: 2.8rem;
    font-weight: 800;
    text-align: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin: 0.5rem 0 1rem 0;
    padding: 0.5rem 0;
    letter-spacing: -0.02em;
}

.subtitle {
    text-align: center;
    color: #666;
    font-size: 1rem;
    margin-top: -0.5rem;
    margin-bottom: 1.5rem;
}

.header-divider {
    height: 3px;
    background: linear-gradient(90deg, transparent, #667eea, #764ba2, transparent);
    margin: 1rem auto 2rem auto;
    border-radius: 2px;
    max-width: 300px;
}

.metric-box {
    background-color: #f0f2f6;
    padding: 1rem;
    border-radius: 0.5rem;
    margin: 0.5rem 0;
}

.success-box {
    background-color: #d4edda;
    border-left: 4px solid #28a745;
    padding: 1rem;
    margin: 1rem 0;
}

.warning-box {
    background-color: #fff3cd;
    border-left: 4px solid #ffc107;
    padding: 1rem;
    margin: 1rem 0;
}
</style>
""", unsafe_allow_html=True)

def main():
    """Interface principale"""
    
    # En-t√™te avec design moderne
    st.markdown('''
    <div style="text-align: center;">
        <h1 class="main-header">ü§ñ Syst√®me Multi-Agents</h1>
        <p class="subtitle">Cr√©ation collaborative de contenu pour le GDD Alteir</p>
        <div class="header-divider"></div>
    </div>
    ''', unsafe_allow_html=True)
    
    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        st.subheader("Mod√®le LLM")
        
        # Mod√®les disponibles avec leurs specs
        MODELS = {
            "GPT-5": {
                "name": "gpt-5",
                "provider": "OpenAI",
                "description": "Mod√®le le plus puissant, raisonnement approfondi",
                "max_tokens": 4000,
                "icon": "üöÄ",
                "uses_reasoning": True,
                "default_reasoning": "medium"
            },
            "GPT-5-mini": {
                "name": "gpt-5-mini",
                "provider": "OpenAI",
                "description": "√âquilibr√© entre performance et co√ªt",
                "max_tokens": 3000,
                "icon": "‚ö°",
                "uses_reasoning": True,
                "default_reasoning": "low"
            },
            "GPT-5-nano": {
                "name": "gpt-5-nano",
                "provider": "OpenAI",
                "description": "Rapide et √©conomique, id√©al pour it√©rations",
                "max_tokens": 2000,
                "icon": "‚ú®",
                "uses_reasoning": True,
                "default_reasoning": "minimal"
            },
            "GPT-4o-mini": {
                "name": "gpt-4o-mini",
                "provider": "OpenAI",
                "description": "Mod√®le de fallback stable",
                "max_tokens": 2000,
                "icon": "üîÑ",
                "uses_reasoning": False
            }
        }
        
        selected_model = st.selectbox(
            "Mod√®le",
            options=list(MODELS.keys()),
            index=2,  # GPT-5-nano par d√©faut
            format_func=lambda x: f"{MODELS[x]['icon']} {x}",
            help="Choisir le mod√®le LLM pour la g√©n√©ration"
        )
        
        # Afficher les d√©tails du mod√®le s√©lectionn√©
        model_info = MODELS[selected_model]
        st.caption(f"**{model_info['provider']}** ‚Ä¢ {model_info['description']}")
        
        st.subheader("Domaine")
        domain = st.selectbox(
            "Domaine", 
            ["Personnages", "Lieux"], 
            index=0,
            help="Choisir le type de contenu √† g√©n√©rer"
        )
        
        # Ic√¥ne selon le domaine
        domain_icons = {
            "Personnages": "üë§",
            "Lieux": "üèõÔ∏è"
        }
        st.caption(f"{domain_icons[domain]} **{domain}**")
        
        st.subheader("üìä Statistiques")
        nb_files = get_outputs_count()  # Utilise le cache
        st.metric("G√©n√©rations", nb_files)
    
    # Tabs
    tab1, tab2, tab3, tab4 = st.tabs(["‚ú® Cr√©er", "üìÇ R√©sultats", "üï∏Ô∏è Graphe", "‚ÑπÔ∏è √Ä propos"])
    
    # TAB 1: Cr√©ation
    with tab1:
        # En-t√™te adapt√© au domaine
        domain_headers = {
            "Personnages": "Cr√©er un Personnage",
            "Lieux": "Cr√©er un Lieu"
        }
        st.header(domain_headers[domain])
        
        # Exemples de briefs selon le domaine
        BRIEF_EXAMPLES_PERSONNAGES = [
            "Un alchimiste qui transforme les √©motions en substances physiques. Genre: Non d√©fini. Esp√®ce: Humain modifi√©. √Çge: 38 cycles. Membre d'une guilde secr√®te, cache une d√©pendance √† ses propres cr√©ations.",
            "Un cartographe solitaire membre d'un culte cherchant des ossements divins. Genre: F√©minin. Esp√®ce: Humaine. √Çge: 45 cycles. Porte un compas en os qui vibre pr√®s des reliques.",
            "Un marchand d'ombres qui vend des souvenirs oubli√©s. Genre: Non binaire. Esp√®ce: Gedroth. √Çge: 102 cycles. Ancien biblioth√©caire devenu contrebandier de m√©moires interdites.",
            "Une chasseuse de primes cybern√©tique traquant son propre cr√©ateur. Genre: F√©minin. Esp√®ce: Hybride m√©canique. √Çge: 28 cycles. Recherche la v√©rit√© sur ses origines.",
            "Un barde aveugle qui voit les √©motions comme des couleurs. Genre: Masculin. Esp√®ce: Humain. √Çge: 34 cycles. Autrefois peintre c√©l√®bre, maintenant musicien errant.",
            "Une arch√©ologue obs√©d√©e par une civilisation disparue dont elle r√™ve chaque nuit. Genre: F√©minin. Esp√®ce: Humaine modifi√©e. √Çge: 41 cycles. Collectionne des artefacts qui lui causent des visions.",
            "Un escargot cyberpunk touche-√†-tout g√©otrouvetout et amateur d'art. Genre: Non d√©fini. Esp√®ce: Escargot modifi√©. √Çge: 27 cycles. R√™ve de cr√©er une galerie underground.",
            "Un ancien soldat reconverti en chef cuisinier utilisant des ingr√©dients interdits. Genre: Masculin. Esp√®ce: Humain. √Çge: 52 cycles. Ses plats r√©veillent des souvenirs enfouis.",
        ]
        
        BRIEF_EXAMPLES_LIEUX = [
            "Une biblioth√®que souterraine abandonn√©e dont les livres murmurent. Taille: Site. R√¥le: Lieu de culte. Autrefois lieu de savoir, maintenant repaire de cultistes.",
            "Un march√© flottant sur des plateformes organiques qui respirent. Taille: Secteur. R√¥le: Lieu commercial. Construit sur le dos d'une cr√©ature endormie.",
            "Les ruines d'une station de purification d'eau devenue sanctuaire. Taille: Point d'int√©r√™t. R√¥le: Zone magique. L'eau y coule encore, mais transforme ce qu'elle touche.",
            "Un quartier vertical dans les entrailles d'un L√©viathan p√©trifi√©. Taille: District. R√¥le: Ville. Sept niveaux de habitations creus√©es dans l'os ancien.",
            "Une forge maudite o√π les armes forg√©es pleurent. Taille: Site. R√¥le: Lieu artisanal. Les artisans y travaillent avec des masques pour ne pas entendre.",
            "Un jardin suspendu o√π poussent des souvenirs cristallis√©s. Taille: Site. R√¥le: Zone naturelle. Entretenu par des jardiniers aveugles qui r√©coltent les r√™ves.",
            "Une gare abandonn√©e devenue labyrinthe de rails fant√¥mes. Taille: Secteur. R√¥le: Lieu unique. Des trains spectraux y passent encore certaines nuits.",
        ]
        
        BRIEF_EXAMPLES = BRIEF_EXAMPLES_LIEUX if domain == "Lieux" else BRIEF_EXAMPLES_PERSONNAGES
        
        # Brief avec boutons d'exemple
        col_brief_label, col_example_btn = st.columns([4, 1])
        with col_brief_label:
            brief_label = "Description du lieu" if domain == "Lieux" else "Description du personnage"
            st.markdown(f"**{brief_label}**")
        with col_example_btn:
            if st.button("üé≤ Brief al√©atoire", help="Charger un exemple de brief"):
                import random
                st.session_state.brief_example = random.choice(BRIEF_EXAMPLES)
                st.rerun()
        
        brief_placeholder = {
            "Personnages": "Ex: Un alchimiste qui transforme les √©motions en substances physiques...",
            "Lieux": "Ex: Une biblioth√®que souterraine dont les livres murmurent..."
        }
        
        brief = st.text_area(
            brief_label,
            value=st.session_state.get('brief_example', ''),
            placeholder=brief_placeholder[domain],
            height=100,
            label_visibility="collapsed"
        )
        
        # Initialiser session state pour les param√®tres
        import random
        if 'random_seed' not in st.session_state:
            st.session_state.random_seed = 0
        
        # Options disponibles selon le domaine
        if domain == "Lieux":
            intent_options = ["hub_central", "passage_oblig√©", "zone_exploration", "lieu_secret"]
            level_options = ["point_interet", "site", "secteur", "district"]
            atmosphere_options = ["oppressante", "vivante", "sacr√©e", "hostile", "accueillante", "neutre"]
            
            # Initialiser les valeurs par d√©faut pour lieux
            if 'intent' not in st.session_state or domain != st.session_state.get('last_domain'):
                st.session_state.intent = "zone_exploration"
            if 'level' not in st.session_state or domain != st.session_state.get('last_domain'):
                st.session_state.level = "site"
            if 'atmosphere' not in st.session_state:
                st.session_state.atmosphere = "neutre"
        else:  # Personnages
            intent_options = ["orthogonal_depth", "vocation_pure", "archetype_assume", "mystere_non_resolu"]
            level_options = ["cameo", "standard", "major"]
            dialogue_options = ["parle", "gestuel", "telepathique", "ecrit_only"]
            
            # Initialiser les valeurs par d√©faut pour personnages
            if 'intent' not in st.session_state or domain != st.session_state.get('last_domain'):
                st.session_state.intent = "orthogonal_depth"
            if 'level' not in st.session_state or domain != st.session_state.get('last_domain'):
                st.session_state.level = "standard"
            if 'dialogue_mode' not in st.session_state:
                st.session_state.dialogue_mode = "parle"
        
        if 'creativity' not in st.session_state:
            st.session_state.creativity = 0.7
        
        # Initialiser reasoning_effort selon le mod√®le
        if 'reasoning_effort' not in st.session_state:
            st.session_state.reasoning_effort = MODELS[selected_model].get("default_reasoning", "minimal")
        
        # Initialiser max_tokens
        if 'max_tokens' not in st.session_state:
            st.session_state.max_tokens = 5000  # Valeur par d√©faut
        
        # M√©moriser le dernier domaine
        st.session_state.last_domain = domain
        
        # Fonction helper pour choisir une valeur diff√©rente
        def random_different(options, current):
            """Choisit une valeur al√©atoire diff√©rente de la valeur actuelle"""
            if len(options) <= 1:
                return options[0] if options else current
            available = [opt for opt in options if opt != current]
            return random.choice(available)
        
        # Callbacks pour optimisation (√©vite reruns)
        def randomize_all():
            st.session_state.intent = random_different(intent_options, st.session_state.intent)
            st.session_state.level = random_different(level_options, st.session_state.level)
            if domain == "Lieux":
                st.session_state.atmosphere = random_different(atmosphere_options, st.session_state.atmosphere)
            else:
                st.session_state.dialogue_mode = random_different(dialogue_options, st.session_state.dialogue_mode)
            while True:
                new_creativity = round(random.uniform(0.5, 0.9), 2)
                if abs(new_creativity - st.session_state.creativity) >= 0.1:
                    st.session_state.creativity = new_creativity
                    break
            st.session_state.random_seed += 1
        
        def randomize_intent():
            st.session_state.intent = random_different(intent_options, st.session_state.intent)
            st.session_state.random_seed += 1
        
        def randomize_level():
            st.session_state.level = random_different(level_options, st.session_state.level)
            st.session_state.random_seed += 1
        
        def randomize_dialogue():
            st.session_state.dialogue_mode = random_different(dialogue_options, st.session_state.dialogue_mode)
            st.session_state.random_seed += 1
        
        def randomize_creativity():
            while True:
                new_creativity = round(random.uniform(0.5, 0.9), 2)
                if abs(new_creativity - st.session_state.creativity) >= 0.1:
                    st.session_state.creativity = new_creativity
                    break
            st.session_state.random_seed += 1
        
        # Profils pr√©d√©finis et bouton d√© global
        st.subheader("Profils & Param√®tres")
        
        # Profils pr√©d√©finis selon le domaine
        if domain == "Lieux":
            PROFILS = {
                "Hub central": {
                    "intent": "hub_central",
                    "level": "district",
                    "atmosphere": "vivante",
                    "creativity": 0.75,
                    "description": "Lieu de convergence, plein de vie et d'activit√©s"
                },
                "Zone d'exploration": {
                    "intent": "zone_exploration",
                    "level": "secteur",
                    "atmosphere": "neutre",
                    "creativity": 0.70,
                    "description": "Zone √† d√©couvrir, secrets et opportunit√©s"
                },
                "Passage oblig√©": {
                    "intent": "passage_oblig√©",
                    "level": "site",
                    "atmosphere": "hostile",
                    "creativity": 0.65,
                    "description": "Lieu de transit, dangers potentiels"
                },
                "Lieu secret": {
                    "intent": "lieu_secret",
                    "level": "point_interet",
                    "atmosphere": "oppressante",
                    "creativity": 0.80,
                    "description": "Cach√©, d√©couverte importante"
                },
                "Sanctuaire": {
                    "intent": "lieu_secret",
                    "level": "site",
                    "atmosphere": "sacr√©e",
                    "creativity": 0.85,
                    "description": "Lieu de culte ou protection, ambiance spirituelle"
                },
            }
        else:  # Personnages
            PROFILS = {
                "Personnage principal": {
                    "intent": "orthogonal_depth",
                    "level": "major",
                    "dialogue_mode": "parle",
                    "creativity": 0.75,
                    "description": "Profondeur maximale, 10-12 r√©pliques, 2-4 relations"
                },
                "PNJ secondaire": {
                    "intent": "orthogonal_depth",
                    "level": "standard",
                    "dialogue_mode": "parle",
                    "creativity": 0.70,
                    "description": "Profondeur moyenne, 8-10 r√©pliques, 1-3 relations"
                },
                "Cameo/Figurant": {
                    "intent": "mystere_non_resolu",
                    "level": "cameo",
                    "dialogue_mode": "parle",
                    "creativity": 0.65,
                    "description": "Pr√©sence minimale, 4-6 r√©pliques, 0-1 relation"
                },
                "Boss/Antagoniste": {
                    "intent": "archetype_assume",
                    "level": "major",
                    "dialogue_mode": "parle",
                    "creativity": 0.80,
                    "description": "Arch√©type assum√©, profondeur maximale"
                },
                "Personnage myst√©rieux": {
                    "intent": "mystere_non_resolu",
                    "level": "standard",
                    "dialogue_mode": "gestuel",
                    "creativity": 0.85,
                    "description": "Zones d'ombre, communication non-verbale"
                },
            }
        
        def apply_profile():
            """Applique un profil pr√©d√©fini automatiquement"""
            if st.session_state.selected_profile != "Personnalis√©":
                profile = PROFILS[st.session_state.selected_profile]
                st.session_state.intent = profile["intent"]
                st.session_state.level = profile["level"]
                if domain == "Lieux":
                    st.session_state.atmosphere = profile["atmosphere"]
                else:
                    st.session_state.dialogue_mode = profile["dialogue_mode"]
                st.session_state.creativity = profile["creativity"]
                st.session_state.random_seed += 1
        
        col_profile, col_dice = st.columns([5, 1])
        with col_profile:
            selected_profile = st.selectbox(
                "Profil pr√©d√©fini",
                ["Personnalis√©"] + list(PROFILS.keys()),
                help="Charger une configuration pr√©d√©finie",
                key="selected_profile",
                on_change=apply_profile
            )
            if selected_profile != "Personnalis√©":
                st.caption(f"‚ÑπÔ∏è {PROFILS[selected_profile]['description']}")
        
        with col_dice:
            st.write("")
            st.write("")
            st.button("üé≤", 
                     help="M√©langer tous les param√®tres", 
                     use_container_width=True,
                     on_click=randomize_all)
        
        st.divider()
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Param√®tres Narratifs")
            
            # Intention narrative (personnages) ou Fonction narrative (lieux)
            col_intent, col_intent_random = st.columns([4, 1])
            with col_intent_random:
                st.write("")  # Spacer
                st.write("")  # Spacer
                st.button("üé≤", key="random_intent", help="Valeur al√©atoire", on_click=randomize_intent)
            with col_intent:
                if domain == "Lieux":
                    intent_label = "Fonction narrative"
                    intent_help = "R√¥le du lieu dans l'histoire"
                else:
                    intent_label = "Intention narrative"
                    intent_help = "Orthogonal = profondeur ‚â† r√¥le visible"
                
                intent = st.selectbox(
                    intent_label,
                    intent_options,
                    index=intent_options.index(st.session_state.intent),
                    help=intent_help,
                    key=f"intent_select_{st.session_state.random_seed}"
                )
            
            # Niveau de d√©tail (personnages) ou √âchelle (lieux)
            col_level, col_level_random = st.columns([4, 1])
            with col_level_random:
                st.write("")  # Spacer
                st.write("")  # Spacer
                st.button("üé≤", key="random_level", help="Valeur al√©atoire", on_click=randomize_level)
            with col_level:
                if domain == "Lieux":
                    level_label = "√âchelle spatiale"
                    level_help = "Taille du lieu : point d'int√©r√™t < site < secteur < district"
                else:
                    level_label = "Niveau de d√©tail"
                    level_help = "cameo: 4-6 r√©pliques | standard: 8-10 | major: 10-12"
                
                level = st.selectbox(
                    level_label,
                    level_options,
                    index=level_options.index(st.session_state.level),
                    help=level_help,
                    key=f"level_select_{st.session_state.random_seed}"
                )
            
            # Mode de dialogue (Personnages) OU Atmosph√®re (Lieux)
            if domain == "Lieux":
                def randomize_atmosphere():
                    st.session_state.atmosphere = random_different(atmosphere_options, st.session_state.atmosphere)
                    st.session_state.random_seed += 1
                
                col_atmosphere, col_atmosphere_random = st.columns([4, 1])
                with col_atmosphere_random:
                    st.write("")  # Spacer
                    st.write("")  # Spacer
                    st.button("üé≤", key="random_atmosphere", help="Valeur al√©atoire", on_click=randomize_atmosphere)
                with col_atmosphere:
                    atmosphere = st.selectbox(
                        "Atmosph√®re",
                        atmosphere_options,
                        index=atmosphere_options.index(st.session_state.atmosphere),
                        help="Ambiance g√©n√©rale du lieu",
                        key=f"atmosphere_select_{st.session_state.random_seed}"
                    )
            else:  # Personnages
                col_dialogue, col_dialogue_random = st.columns([4, 1])
                with col_dialogue_random:
                    st.write("")  # Spacer
                    st.write("")  # Spacer
                    st.button("üé≤", key="random_dialogue", help="Valeur al√©atoire", on_click=randomize_dialogue)
                with col_dialogue:
                    dialogue_mode = st.selectbox(
                        "Mode de dialogue",
                        dialogue_options,
                        index=dialogue_options.index(st.session_state.dialogue_mode),
                        help="Comment le personnage communique",
                        key=f"dialogue_select_{st.session_state.random_seed}"
                    )
        
        with col2:
            st.subheader("Param√®tres Techniques")
            
            # Temp√©rature (GPT-4) OU Reasoning Effort (GPT-5)
            if model_info.get("uses_reasoning"):
                # GPT-5 : Reasoning Effort
                reasoning_options = ["minimal", "low", "medium", "high"]
                
                def randomize_reasoning():
                    st.session_state.reasoning_effort = random_different(reasoning_options, st.session_state.reasoning_effort)
                    st.session_state.random_seed += 1
                
                col_reasoning, col_reasoning_random = st.columns([4, 1])
                with col_reasoning_random:
                    st.write("")  # Spacer
                    st.write("")  # Spacer
                    st.button("üé≤", key="random_reasoning", help="Valeur al√©atoire", on_click=randomize_reasoning)
                with col_reasoning:
                    reasoning_effort = st.selectbox(
                        "Effort de raisonnement",
                        options=reasoning_options,
                        index=reasoning_options.index(st.session_state.reasoning_effort),
                        help="minimal = rapide | low = √©quilibr√© | medium = standard | high = approfondi",
                        key=f"reasoning_select_{st.session_state.random_seed}"
                    )
                    creativity = None  # Pas utilis√© pour GPT-5
            else:
                # GPT-4 : Temp√©rature classique
                col_creativity, col_creativity_random = st.columns([4, 1])
                with col_creativity_random:
                    st.write("")  # Spacer
                    st.write("")  # Spacer
                    st.write("")  # Spacer
                    st.write("")  # Spacer
                    st.button("üé≤", key="random_creativity", help="Valeur al√©atoire", on_click=randomize_creativity)
                with col_creativity:
                    creativity = st.slider(
                        "Cr√©ativit√© (temp√©rature)",
                        min_value=0.0,
                        max_value=1.0,
                        value=st.session_state.creativity,
                        step=0.01,
                        help="0 = d√©terministe | 1 = tr√®s cr√©atif",
                        key=f"creativity_slider_{st.session_state.random_seed}"
                    )
                    reasoning_effort = None  # Pas utilis√© pour GPT-4
            
            # Max tokens (pour tous les mod√®les)
            st.write("")  # Spacer
            max_tokens = st.slider(
                "Max tokens (sortie)",
                min_value=1000,
                max_value=30000,
                value=st.session_state.max_tokens,
                step=1000,
                help="Limite de tokens pour la r√©ponse (1000-30000). ‚ö†Ô∏è GPT-5 utilise des tokens pour le reasoning !",
                key=f"max_tokens_slider_{st.session_state.random_seed}"
            )
            
            # Configuration affich√©e selon le domaine et le mod√®le
            config_lines = [f"- Intent: `{intent}`"]
            
            if domain == "Lieux":
                config_lines.extend([
                    f"- √âchelle: `{level}`",
                    f"- Atmosph√®re: `{atmosphere}`"
                ])
            else:
                config_lines.extend([
                    f"- Niveau: `{level}`",
                    f"- Dialogue: `{dialogue_mode}`"
                ])
            
            # Param√®tre de cr√©ativit√©/reasoning selon le mod√®le
            if model_info.get("uses_reasoning"):
                config_lines.append(f"- Reasoning: `{reasoning_effort}`")
            else:
                config_lines.append(f"- Temp√©rature: `{creativity}`")
            
            # Max tokens pour tous
            config_lines.append(f"- Max tokens: `{max_tokens}`")
            
            st.info("**Configuration:**\n" + "\n".join(config_lines))
        
        # Mettre √† jour session state avec les valeurs choisies manuellement
        st.session_state.intent = intent
        st.session_state.level = level
        if domain == "Lieux":
            st.session_state.atmosphere = atmosphere
            dialogue_mode = "none"  # Valeur par d√©faut pour lieux
        else:
            st.session_state.dialogue_mode = dialogue_mode
        
        # Mettre √† jour selon le type de mod√®le
        if model_info.get("uses_reasoning"):
            st.session_state.reasoning_effort = reasoning_effort
        else:
            st.session_state.creativity = creativity
        
        # Mettre √† jour max_tokens
        st.session_state.max_tokens = max_tokens
        
        # Bouton de g√©n√©ration adapt√© au domaine
        button_text = {
            "Personnages": "üöÄ G√©n√©rer le Personnage",
            "Lieux": "üöÄ G√©n√©rer le Lieu"
        }
        error_text = {
            "Personnages": "‚ö†Ô∏è Veuillez fournir une description du personnage",
            "Lieux": "‚ö†Ô∏è Veuillez fournir une description du lieu"
        }
        
        if st.button(button_text[domain], type="primary", use_container_width=True):
            if not brief:
                st.error(error_text[domain])
            else:
                generate_content(brief, intent, level, dialogue_mode, creativity, reasoning_effort, max_tokens, selected_model, MODELS[selected_model], domain)
    
    # TAB 2: R√©sultats
    with tab2:
        st.header("R√©sultats G√©n√©r√©s")
        
        show_results()
    
    # TAB 3: Graphe de relations
    with tab3:
        st.header("üï∏Ô∏è Graphe de Relations")
        
        st.info("""
        üìä **Visualisation des relations entre entit√©s**
        
        Cette fonctionnalit√© permet de visualiser les liens entre personnages, lieux, communaut√©s et objets dans l'univers Alteir.
        """)
        
        # S√©lection du type de graphe
        graph_type = st.selectbox(
            "Type de graphe",
            ["Personnages", "Lieux", "Tout l'univers"],
            help="Choisissez quelles entit√©s afficher"
        )
        
        # Filtres
        col_filter1, col_filter2 = st.columns(2)
        with col_filter1:
            show_communities = st.checkbox("Communaut√©s", value=True)
            show_species = st.checkbox("Esp√®ces", value=True)
        with col_filter2:
            show_locations = st.checkbox("Lieux", value=True)
            show_objects = st.checkbox("Objets", value=False)
        
        st.divider()
        
        # Placeholder pour le graphe
        st.info("üöß **Fonctionnalit√© en d√©veloppement**")
        st.markdown("""
        Le graphe de relations permettra de :
        - Visualiser les connexions entre entit√©s
        - Explorer les r√©seaux de personnages
        - Identifier les hubs et points cl√©s
        - D√©tecter les incoh√©rences de relations
        
        **Impl√©mentation pr√©vue** : NetworkX + Plotly pour visualisation interactive
        """)
        
        # Exemple de donn√©es de graphe (mockup)
        if st.checkbox("Voir exemple de structure de donn√©es"):
            st.code("""
{
  "nodes": [
    {"id": "personnage_1", "label": "Norrik", "type": "personnage"},
    {"id": "lieu_1", "label": "Biblioth√®que des Murmures", "type": "lieu"},
    {"id": "communaute_1", "label": "Les Cartographes", "type": "communaute"}
  ],
  "edges": [
    {"source": "personnage_1", "target": "lieu_1", "type": "vit_a"},
    {"source": "personnage_1", "target": "communaute_1", "type": "membre_de"}
  ]
}
            """, language="json")
    
    # TAB 4: √Ä propos
    with tab4:
        st.header("√Ä propos")
        
        st.markdown("""
        ### üéØ Syst√®me Multi-Agents GDD Alteir
        
        **Architecture:**
        - 4 agents g√©n√©riques (Writer, Reviewer, Corrector, Validator)
        - Configuration par domaine (Personnages, Lieux, etc.)
        - LangGraph pour orchestration
        - GPT-5-nano pour g√©n√©ration
        
        **Workflow:**
        1. **Writer** ‚Üí G√©n√®re le contenu initial
        2. **Reviewer** ‚Üí Analyse la coh√©rence narrative
        3. **Corrector** ‚Üí Corrige la forme
        4. **Validator** ‚Üí Validation finale
        
        **Principes Narratifs (Personnages):**
        - Orthogonalit√© r√¥le ‚Üî profondeur
        - Structure Surface / Profondeur / Monde
        - Temporalit√© IS / WAS / COULD-HAVE-BEEN
        - Show > Tell
        - Relations concr√®tes (prix, dette, d√©lai, tabou)
        
        **Outputs:**
        - JSON complet avec m√©tadonn√©es
        - Markdown format√© pour lecture
        - Scores de qualit√© (coh√©rence, compl√©tude, qualit√©)
        """)

def create_llm(model_name: str, model_config: dict, creativity: float = None, reasoning_effort: str = None, max_tokens: int = None):
    """Cr√©e une instance LLM selon le mod√®le choisi"""
    from langchain_openai import ChatOpenAI
    
    # Configuration de base
    llm_config = {
        "model": model_config["name"],
        "max_tokens": max_tokens or model_config["max_tokens"],
    }
    
    # Configuration selon le type de mod√®le
    if model_config.get("uses_reasoning"):
        # GPT-5 : utilise reasoning au lieu de temperature
        llm_config["use_responses_api"] = True
        llm_config["reasoning"] = {
            "effort": reasoning_effort or model_config.get("default_reasoning", "minimal")
        }
    else:
        # GPT-4 : utilise temperature classique
        llm_config["temperature"] = creativity
    
    return ChatOpenAI(**llm_config)

def generate_content(brief, intent, level, dialogue_mode, creativity, reasoning_effort, max_tokens, model_name, model_config, domain):
    """G√©n√®re du contenu (personnage ou lieu) selon le domaine"""
    
    # Lazy load des d√©pendances lourdes selon le domaine
    ContentWorkflow, WriterConfig, domain_config = load_workflow_dependencies(domain.lower())
    
    # Cr√©er le LLM selon le mod√®le choisi
    llm = create_llm(model_name, model_config, creativity=creativity, reasoning_effort=reasoning_effort, max_tokens=max_tokens)
    
    # Configuration
    writer_config = WriterConfig(
        intent=intent,
        level=level,
        dialogue_mode=dialogue_mode,
        creativity=creativity
    )
    
    # Workflow avec le LLM choisi
    workflow = ContentWorkflow(domain_config, llm=llm)
    
    # Progress bar d√©taill√©e avec √©tapes
    progress_container = st.container()
    
    with progress_container:
        # Cr√©er les colonnes pour les √©tapes
        cols = st.columns(4)
        steps = [
            {"name": "Writer", "icon": "‚úçÔ∏è", "desc": "G√©n√©ration"},
            {"name": "Reviewer", "icon": "üîç", "desc": "Analyse"},
            {"name": "Corrector", "icon": "‚úèÔ∏è", "desc": "Correction"},
            {"name": "Validator", "icon": "‚úÖ", "desc": "Validation"}
        ]
        
        # Initialiser les placeholders pour chaque √©tape
        step_placeholders = []
        for i, (col, step) in enumerate(zip(cols, steps)):
            with col:
                placeholder = st.empty()
                step_placeholders.append(placeholder)
                placeholder.markdown(f"""
                <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #1E1E1E;'>
                    <div style='font-size: 24px;'>{step['icon']}</div>
                    <div style='font-size: 12px; color: #888;'>{step['name']}</div>
                    <div style='font-size: 10px; color: #666;'>{step['desc']}</div>
                </div>
                """, unsafe_allow_html=True)
        
        progress_bar = st.progress(0)
        status_text = st.empty()
        time_estimate = st.empty()
        time_estimate.text("‚è±Ô∏è Temps estim√© : 30-45 secondes")
    
    try:
        import time
        start_time = time.time()
        
        # √âtape 1: Writer
        step_placeholders[0].markdown(f"""
        <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #667eea; color: white;'>
            <div style='font-size: 24px;'>‚úçÔ∏è</div>
            <div style='font-size: 12px; font-weight: bold;'>Writer</div>
            <div style='font-size: 10px;'>En cours...</div>
        </div>
        """, unsafe_allow_html=True)
        status_text.text("‚úçÔ∏è Writer : G√©n√©ration du contenu initial...")
        progress_bar.progress(10)
        
        # Simuler l'avancement pendant l'ex√©cution
        result = workflow.run(brief, writer_config)
        
        # √âtape 1 termin√©e
        step_placeholders[0].markdown(f"""
        <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #28a745; color: white;'>
            <div style='font-size: 24px;'>‚úÖ</div>
            <div style='font-size: 12px; font-weight: bold;'>Writer</div>
            <div style='font-size: 10px;'>Termin√©</div>
        </div>
        """, unsafe_allow_html=True)
        progress_bar.progress(25)
        
        # √âtape 2: Reviewer
        step_placeholders[1].markdown(f"""
        <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #667eea; color: white;'>
            <div style='font-size: 24px;'>üîç</div>
            <div style='font-size: 12px; font-weight: bold;'>Reviewer</div>
            <div style='font-size: 10px;'>En cours...</div>
        </div>
        """, unsafe_allow_html=True)
        status_text.text("üîç Reviewer : Analyse de coh√©rence narrative...")
        progress_bar.progress(50)
        
        # √âtape 2 termin√©e
        step_placeholders[1].markdown(f"""
        <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #28a745; color: white;'>
            <div style='font-size: 24px;'>‚úÖ</div>
            <div style='font-size: 12px; font-weight: bold;'>Reviewer</div>
            <div style='font-size: 10px;'>Termin√©</div>
        </div>
        """, unsafe_allow_html=True)
        
        # √âtape 3: Corrector
        step_placeholders[2].markdown(f"""
        <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #667eea; color: white;'>
            <div style='font-size: 24px;'>‚úèÔ∏è</div>
            <div style='font-size: 12px; font-weight: bold;'>Corrector</div>
            <div style='font-size: 10px;'>En cours...</div>
        </div>
        """, unsafe_allow_html=True)
        status_text.text("‚úèÔ∏è Corrector : Correction linguistique...")
        progress_bar.progress(75)
        
        # √âtape 3 termin√©e
        step_placeholders[2].markdown(f"""
        <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #28a745; color: white;'>
            <div style='font-size: 24px;'>‚úÖ</div>
            <div style='font-size: 12px; font-weight: bold;'>Corrector</div>
            <div style='font-size: 10px;'>Termin√©</div>
        </div>
        """, unsafe_allow_html=True)
        
        # √âtape 4: Validator
        step_placeholders[3].markdown(f"""
        <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #667eea; color: white;'>
            <div style='font-size: 24px;'>‚úÖ</div>
            <div style='font-size: 12px; font-weight: bold;'>Validator</div>
            <div style='font-size: 10px;'>En cours...</div>
        </div>
        """, unsafe_allow_html=True)
        status_text.text("‚úÖ Validator : Validation finale...")
        progress_bar.progress(90)
        
        # √âtape 4 termin√©e
        step_placeholders[3].markdown(f"""
        <div style='text-align: center; padding: 10px; border-radius: 5px; background-color: #28a745; color: white;'>
            <div style='font-size: 24px;'>‚úÖ</div>
            <div style='font-size: 12px; font-weight: bold;'>Validator</div>
            <div style='font-size: 10px;'>Termin√©</div>
        </div>
        """, unsafe_allow_html=True)
        
        elapsed_time = time.time() - start_time
        status_text.text(f"‚úÖ Termin√© en {elapsed_time:.1f}s !")
        progress_bar.progress(100)
        time_estimate.text("")
        
        # Ajouter les m√©tadonn√©es du mod√®le au r√©sultat
        result['model_used'] = model_name
        result['model_config'] = model_config
        
        # Sauvegarder
        json_file, md_file = workflow.save_results(result)
        
        # Afficher r√©sultats
        success_msg = {
            "personnages": f"‚úÖ Personnage g√©n√©r√© avec succ√®s ! (Mod√®le: {model_config['icon']} {model_name})",
            "lieux": f"‚úÖ Lieu g√©n√©r√© avec succ√®s ! (Mod√®le: {model_config['icon']} {model_name})"
        }
        st.success(success_msg[domain.lower()])
        
        # M√©triques
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric(
                "Coh√©rence",
                f"{result['coherence_score']:.2f}",
                delta="Bon" if result['coherence_score'] >= 0.7 else "√Ä am√©liorer"
            )
        
        with col2:
            st.metric(
                "Compl√©tude",
                f"{result['completeness_score']:.2f}",
                delta="Complet" if result['completeness_score'] >= 0.8 else "Incomplet"
            )
        
        with col3:
            st.metric(
                "Qualit√©",
                f"{result['quality_score']:.2f}",
                delta="Bon" if result['quality_score'] >= 0.7 else "√Ä am√©liorer"
            )
        
        # Statut
        if result['ready_for_publication']:
            st.markdown('<div class="success-box">‚úÖ <b>Pr√™t pour publication</b></div>', unsafe_allow_html=True)
        else:
            st.markdown('<div class="warning-box">‚ö†Ô∏è <b>N√©cessite r√©vision</b></div>', unsafe_allow_html=True)
        
        # Contenu
        with st.expander("üìÑ Voir le contenu g√©n√©r√©", expanded=True):
            st.markdown(result['content'])
        
        # Probl√®mes
        if result['review_issues']:
            with st.expander(f"‚ö†Ô∏è Probl√®mes identifi√©s ({len(result['review_issues'])})"):
                for issue in result['review_issues']:
                    severity = issue['severity']
                    if severity == 'critical':
                        severity_icon = "üî¥"
                        box_color = "#f8d7da"
                        border_color = "#dc3545"
                    elif severity == 'major':
                        severity_icon = "üü†"
                        box_color = "#fff3cd"
                        border_color = "#ffc107"
                    else:
                        severity_icon = "üü°"
                        box_color = "#d1ecf1"
                        border_color = "#17a2b8"
                    
                    st.markdown(f"""
                    <div style="background-color: {box_color}; border-left: 4px solid {border_color}; padding: 1rem; margin: 0.5rem 0; border-radius: 0.3rem;">
                        {severity_icon} <b>{issue.get('category', 'General').capitalize()}</b><br>
                        {issue['description']}
                        {f"<br><i>üí° Suggestion: {issue['suggestion']}</i>" if issue.get('suggestion') else ""}
                    </div>
                    """, unsafe_allow_html=True)
        
        # Corrections
        if result['corrections']:
            with st.expander(f"‚úèÔ∏è Corrections ({len(result['corrections'])})"):
                for corr in result['corrections']:
                    st.markdown(f"""
                    <div style="background-color: #e7f3ff; border-left: 4px solid #2196F3; padding: 1rem; margin: 0.5rem 0; border-radius: 0.3rem;">
                        <b>{corr['type']}</b>: <code>{corr['original']}</code> ‚Üí <code>{corr['corrected']}</code>
                        {f"<br><i>{corr['explanation']}</i>" if corr.get('explanation') else ""}
                    </div>
                    """, unsafe_allow_html=True)
        
        # Fichiers et export
        col_files, col_export = st.columns([2, 1])
        
        with col_files:
            st.info(f"""
            **Fichiers sauvegard√©s:**
            - üìä JSON: `{json_file.name}`
            - üìù Markdown: `{md_file.name}`
            """)
        
        with col_export:
            st.write("")
            if st.button("üì§ Exporter vers Notion", use_container_width=True, help="Cr√©er une page dans Notion"):
                export_to_notion(result)
                
            if st.button("üíæ T√©l√©charger JSON", use_container_width=True):
                with open(json_file, 'r', encoding='utf-8') as f:
                    st.download_button(
                        label="üì• T√©l√©charger",
                        data=f.read(),
                        file_name=json_file.name,
                        mime="application/json"
                    )
        
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la g√©n√©ration: {e}")

def export_to_notion(result):
    """Exporte le r√©sultat vers Notion avec MCP"""
    try:
        with st.spinner("üì§ Export vers Notion en cours..."):
            # R√©cup√©rer les m√©tadonn√©es du personnage
            metadata = result.get('writer_metadata', {})
            
            # Pr√©parer les propri√©t√©s pour Notion
            properties = {
                "Nom": metadata.get('nom', 'Sans nom'),
                "Type": metadata.get('type', 'PNJ'),
                "Esp√®ce": metadata.get('espece', ''),
                "Genre": metadata.get('genre', 'Non d√©fini'),
                "√âtat": "Brouillon IA",
            }
            
            # Ajouter les propri√©t√©s optionnelles si pr√©sentes
            if metadata.get('age'):
                properties['√Çge'] = int(metadata.get('age', 0))
            if metadata.get('alias'):
                properties['Alias'] = metadata.get('alias')
            if metadata.get('occupation'):
                properties['Occupation'] = metadata.get('occupation')
            if metadata.get('axe_ideologique'):
                properties['Axe id√©ologique'] = metadata.get('axe_ideologique')
            if metadata.get('archetype'):
                properties['Arch√©type litt√©raire'] = [metadata.get('archetype')]
            if metadata.get('langage'):
                properties['Langage'] = [metadata.get('langage')]
            
            # Log pour debug
            with st.expander("üîç Debug - Donn√©es envoy√©es", expanded=False):
                st.write("**Propri√©t√©s:**")
                st.json(properties)
                st.write("**Contenu (pr√©visualisation):**")
                st.text(result['content'][:300] + "...")
            
            # Base de donn√©es Personnages
            DATABASE_ID = "1886e4d21b4581a29340f77f5f2e5885"  # Personnages
            
            # Appel API REST Notion pour cr√©er la page
            try:
                import requests
                import os
                
                # Pr√©parer les propri√©t√©s au format Notion API
                notion_properties = {}
                
                # Title property
                notion_properties["Nom"] = {
                    "title": [{"text": {"content": properties.get("Nom", "Sans nom")}}]
                }
                
                # Select properties
                if properties.get("Type"):
                    notion_properties["Type"] = {"select": {"name": properties["Type"]}}
                if properties.get("Genre"):
                    notion_properties["Genre"] = {"select": {"name": properties["Genre"]}}
                if properties.get("√âtat"):
                    notion_properties["√âtat"] = {"status": {"name": properties["√âtat"]}}
                if properties.get("Axe id√©ologique"):
                    notion_properties["Axe id√©ologique"] = {"select": {"name": properties["Axe id√©ologique"]}}
                
                # Rich text properties
                if properties.get("Esp√®ce"):
                    notion_properties["Esp√®ce"] = {
                        "rich_text": [{"text": {"content": properties["Esp√®ce"]}}]
                    }
                if properties.get("Alias"):
                    notion_properties["Alias"] = {
                        "rich_text": [{"text": {"content": properties["Alias"]}}]
                    }
                if properties.get("Occupation"):
                    notion_properties["Occupation"] = {
                        "rich_text": [{"text": {"content": properties["Occupation"]}}]
                    }
                
                # Number property
                if properties.get("√Çge"):
                    notion_properties["√Çge"] = {"number": properties["√Çge"]}
                
                # Multi-select properties
                if properties.get("Arch√©type litt√©raire"):
                    notion_properties["Arch√©type litt√©raire"] = {
                        "multi_select": [{"name": arch} for arch in properties["Arch√©type litt√©raire"]]
                    }
                if properties.get("Langage"):
                    notion_properties["Langage"] = {
                        "multi_select": [{"name": lang} for lang in properties["Langage"]]
                    }
                
                # Cr√©er la page via API REST
                headers = {
                    "Authorization": f"Bearer {os.getenv('NOTION_TOKEN')}",
                    "Notion-Version": "2022-06-28",
                    "Content-Type": "application/json"
                }
                
                payload = {
                    "parent": {"database_id": DATABASE_ID.replace("-", "")},
                    "properties": notion_properties
                }
                
                response = requests.post(
                    "https://api.notion.com/v1/pages",
                    headers=headers,
                    json=payload
                )
                
                if response.status_code != 200:
                    st.error(f"Erreur API Notion: {response.status_code}")
                    st.json(response.json())
                    raise Exception(f"API Error: {response.text}")
                
                page_data = response.json()
                page_url = page_data.get('url', '#')
                page_id = page_data.get('id', 'unknown')
                
                st.success(f"""
                ‚úÖ **Personnage export√© vers Notion !**
                
                üìÑ **Lien de la fiche:** [{properties['Nom']}]({page_url})
                
                Le personnage a √©t√© cr√©√© dans la base Personnages.
                
                **Informations :**
                - ID de la page : `{page_id}`
                - Base : Personnages
                - √âtat : Brouillon IA
                
                **Prochaines √©tapes :**
                - V√©rifier la page dans Notion
                - Compl√©ter les relations (Communaut√©s, Lieux, etc.)
                - Valider et changer l'√©tat si n√©cessaire
                """)
                
                st.balloons()  # Animation de c√©l√©bration
                
            except Exception as mcp_error:
                st.error(f"‚ùå Erreur MCP lors de la cr√©ation : {mcp_error}")
                
                # Afficher les d√©tails pour debugging
                with st.expander("üîß D√©tails de l'erreur", expanded=True):
                    st.exception(mcp_error)
                    st.write("**Configuration actuelle:**")
                    st.json({
                        "data_source_id": DATA_SOURCE_ID,
                        "properties": properties,
                        "content_length": len(result['content'])
                    })
                
                raise
    
    except Exception as e:
        st.error(f"‚ùå Erreur lors de l'export : {e}")
        st.exception(e)  # Afficher la stack trace compl√®te

def show_results():
    """Affiche les r√©sultats g√©n√©r√©s"""
    
    # Utilise le cache pour lister les fichiers
    file_names = list_output_files()
    
    if not file_names:
        st.info("Aucun r√©sultat g√©n√©r√© pour le moment.")
        return
    
    st.write(f"**{len(file_names)} r√©sultat(s) g√©n√©r√©(s)**")
    
    # S√©lecteur
    selected_file = st.selectbox("S√©lectionner un r√©sultat", file_names)
    
    if selected_file:
        # Utilise le cache pour charger le fichier
        data = load_result_file(selected_file)
        
        if not data:
            st.error("Erreur lors du chargement du fichier")
            return
        
        # Afficher
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Coh√©rence", f"{data['coherence_score']:.2f}")
        with col2:
            st.metric("Compl√©tude", f"{data['completeness_score']:.2f}")
        with col3:
            st.metric("Qualit√©", f"{data['quality_score']:.2f}")
        
        # Mod√®le utilis√© (si disponible)
        if data.get('model_used'):
            model_config = data.get('model_config', {})
            icon = model_config.get('icon', 'ü§ñ')
            st.info(f"{icon} **Mod√®le utilis√© :** {data['model_used']}")
        
        # Statut
        if data['ready_for_publication']:
            st.success("‚úÖ Pr√™t pour publication")
        else:
            st.warning("‚ö†Ô∏è N√©cessite r√©vision")
        
        # Actions
        col_export, col_download = st.columns(2)
        
        with col_export:
            if st.button("üì§ Exporter vers Notion", use_container_width=True, help="Cr√©er une page dans Notion", key=f"export_{selected_file}"):
                export_to_notion(data)
        
        with col_download:
            # Bouton de t√©l√©chargement JSON
            from pathlib import Path
            json_path = Path("outputs") / f"{selected_file}.json"
            if json_path.exists():
                with open(json_path, 'r', encoding='utf-8') as f:
                    st.download_button(
                        label="üíæ T√©l√©charger JSON",
                        data=f.read(),
                        file_name=f"{selected_file}.json",
                        mime="application/json",
                        use_container_width=True
                    )
        
        st.divider()
        
        # Contenu
        with st.expander("üìÑ Contenu", expanded=True):
            st.markdown(data['content'])
        
        # Probl√®mes et corrections
        if data.get('review_issues'):
            with st.expander(f"‚ö†Ô∏è Probl√®mes identifi√©s ({len(data['review_issues'])})"):
                for issue in data['review_issues']:
                    severity = issue.get('severity', 'minor')
                    if severity == 'critical':
                        severity_icon = "üî¥"
                        box_color = "#f8d7da"
                        border_color = "#dc3545"
                    elif severity == 'major':
                        severity_icon = "üü†"
                        box_color = "#fff3cd"
                        border_color = "#ffc107"
                    else:
                        severity_icon = "üü°"
                        box_color = "#d1ecf1"
                        border_color = "#17a2b8"
                    
                    st.markdown(f"""
                    <div style="background-color: {box_color}; border-left: 4px solid {border_color}; padding: 1rem; margin: 0.5rem 0; border-radius: 0.3rem;">
                        {severity_icon} <b>{issue.get('category', 'General').capitalize()}</b><br>
                        {issue.get('description', 'N/A')}
                        {f"<br><i>üí° Suggestion: {issue['suggestion']}</i>" if issue.get('suggestion') else ""}
                    </div>
                    """, unsafe_allow_html=True)
        
        if data.get('corrections'):
            with st.expander(f"‚úèÔ∏è Corrections ({len(data['corrections'])})"):
                for corr in data['corrections']:
                    st.markdown(f"""
                    <div style="background-color: #e7f3ff; border-left: 4px solid #2196F3; padding: 1rem; margin: 0.5rem 0; border-radius: 0.3rem;">
                        <b>{corr.get('type', 'N/A')}</b>: <code>{corr.get('original', '')}</code> ‚Üí <code>{corr.get('corrected', '')}</code>
                        {f"<br><i>{corr['explanation']}</i>" if corr.get('explanation') else ""}
                    </div>
                    """, unsafe_allow_html=True)
        
        # M√©tadonn√©es
        with st.expander("üìä M√©tadonn√©es"):
            st.json(data['writer_metadata'])

if __name__ == "__main__":
    main()

