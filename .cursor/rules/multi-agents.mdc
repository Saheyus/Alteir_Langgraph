---
description: Architecture multi-agents avec LangGraph et MCP Notion
globs: agents/**/*.py,workflows/**/*.py,config/**/*.py
alwaysApply: false
---

# Système Multi-Agents GDD Alteir

## 🤖 Modèles LLM

### OpenAI GPT-5-nano (Production)
```python
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(
    model="gpt-5-nano",  # VALIDE depuis août 2025
    use_responses_api=True,
    extra_body={
        "reasoning": {"effort": "minimal"},
        "max_output_tokens": 1000,
    }
)
```

### Multi-Provider avec LLMAdapter
**TOUJOURS utiliser `LLMAdapter`** pour abstraction fournisseur :

```python
from agents.base.llm_utils import LLMAdapter

adapter = LLMAdapter(llm)  # Fonctionne avec OpenAI, Anthropic, Mistral, Ollama
result = adapter.get_structured_output(prompt, schema=MySchema)
```

## 🏗️ Architecture Agents

### Créer un nouvel agent
```python
from agents.base.base_agent import BaseAgent, AgentResult
from agents.base.domain_config import DomainConfig

class MyAgent(BaseAgent):
    def __init__(self, domain_config: DomainConfig, llm=None):
        super().__init__(domain_config, llm)
    
    def process(self, input_data, context=None) -> AgentResult:
        # 1. Utiliser self.domain_config pour spécificités
        # 2. Utiliser self.llm pour appels LLM
        # 3. Retourner AgentResult
        pass
```

### 4 Agents Génériques
1. **WriterAgent**: Génération contenu
2. **ReviewerAgent**: Analyse cohérence
3. **CorrectorAgent**: Correction linguistique
4. **ValidatorAgent**: Validation finale

**Ne PAS créer de nouveaux agents** → Créer une **DomainConfig** à la place !

## 📊 Structured Outputs (OBLIGATOIRE)

### ✅ TOUJOURS utiliser Structured Outputs
```python
from pydantic import BaseModel, Field

class MyResult(BaseModel):
    field1: str = Field(description="...")
    field2: List[str]

adapter = LLMAdapter(llm)
result = adapter.get_structured_output(prompt, schema=MyResult)
# result est typé, pas de parsing manuel !
```

### ❌ NE JAMAIS faire de parsing manuel
```python
# ❌ ÉVITER CECI
if '[CORRECTION:' in line:
    parts = line.split(']', 1)

# ✅ FAIRE CECI
result = adapter.get_structured_output(prompt, schema=CorrectionResult)
for corr in result.corrections:
    print(corr.type, corr.original)
```

## 🔄 Workflows LangGraph

### Pattern Standard
```python
from langgraph.graph import StateGraph, END
from typing import TypedDict

class MyState(TypedDict):
    content: str
    metadata: dict

def node_function(state: MyState) -> dict:
    return {"content": "..."}

graph = StateGraph(MyState)
graph.add_node("node1", node_function)
graph.add_edge("node1", END)
app = graph.compile()
```

### Sauvegarde Résultats
- **JSON** (`outputs/*.json`): État complet
- **Markdown** (`outputs/*.md`): Contenu lisible

## 🖥️ Lancement Interfaces

### Fichiers .cmd (Windows - Recommandé)
```cmd
# Menu principal avec toutes les options
GDD_Alteir.cmd

# Lancer directement l'application
lancer_app.cmd

# Lancer les tests
lancer_tests.cmd

# Lancer une démo
lancer_demo.cmd
```

### Streamlit (Manuel)
```bash
# IMPORTANT: Utiliser chemin ABSOLU sur Windows
python -m streamlit run "F:\Projets\Langgraph Alteir\app_streamlit.py"

# ❌ NE PAS faire (ne trouve pas le fichier en background)
streamlit run app_streamlit.py
```

L'app s'ouvre automatiquement sur **http://localhost:8501**

### CLI
```bash
python app_cli.py
```

### Demo Rich
```bash
python demo_workflow.py
```

## 📝 Conventions Code

### Nommage
- **Classes**: `PascalCase` (WriterAgent, DomainConfig)
- **Fonctions/Variables**: `snake_case` (process_content)
- **Constantes**: `UPPER_SNAKE_CASE` (PERSONNAGES_CONFIG)

### Type Hints OBLIGATOIRES
```python
def process(self, content: str, context: Dict[str, Any] = None) -> AgentResult:
    pass
```

### Docstrings Google
```python
def my_function(param1: str) -> bool:
    """
    Description courte.
    
    Args:
        param1: Description
        
    Returns:
        Description retour
    """
    pass
```

## 🚨 Erreurs à Éviter

❌ Parsing manuel de texte LLM
❌ Hardcoder le provider (toujours `LLMAdapter`)
❌ Oublier type hints
❌ Ignorer structured outputs
❌ Créer agents spécialisés → Créer `DomainConfig`
❌ Modèles inexistants (GPT-5-nano existe depuis août 2025)

## 🧪 Tests

### Structure des Tests
```
tests/
  test_notion_integration.py    # Tests MCP Notion
  test_narrative_template.py    # Tests templates narratifs
  test_real_data.py            # Tests avec vraies données
```

### Créer un Test
```python
#!/usr/bin/env python3
"""
Tests pour [domaine/fonctionnalité]
"""
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))

from rich.console import Console
from rich.panel import Panel

console = Console()

def test_my_feature():
    """Test: Description du test"""
    console.print(Panel("[bold cyan]=== Test: Mon Test ===[/bold cyan]", expand=False))
    
    try:
        # Code de test
        result = my_function()
        
        if result:
            console.print("[green]✓ Test réussi[/green]")
            return True
        else:
            console.print("[red]✗ Test échoué[/red]")
            return False
            
    except Exception as e:
        console.print(f"[bold red]✗ Erreur:[/bold red] {e}")
        return False

def run_tests():
    """Exécute tous les tests"""
    results = [
        ("Mon Test", test_my_feature()),
    ]
    
    # Résumé
    for test_name, success in results:
        status = "[green]✓[/green]" if success else "[red]✗[/red]"
        console.print(f"{status} {test_name}")

if __name__ == "__main__":
    run_tests()
```

### Lancer les Tests
```bash
# Test spécifique
python tests/test_narrative_template.py

# Tous les tests d'intégration
python tests/test_notion_integration.py

# Tests avec vraies données
python tests/test_real_data.py
```

## ✅ Bonnes Pratiques

✓ `LLMAdapter` pour multi-provider
✓ Structured Outputs avec Pydantic
✓ `DomainConfig` pour spécialisation
✓ Sauvegarder JSON + Markdown
✓ Tester avec plusieurs providers
✓ Type hints partout
✓ Workflows LangGraph simples
✓ Tests permanents dans `tests/` (pas de fichiers temporaires)
✓ Utiliser Rich pour l'affichage des tests
